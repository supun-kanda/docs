<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: test3.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: test3.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * 
 * @param {Number} num any number 
 * @param {String} str any String
 * @description This will be the master object of this tutorial. As in there's will not be any error handling to input differnet parameter types. The main goal is to show that the methods of inheriting
 */
let Master = function(num,str){
    this.num = num
    this.str = str
}
/**
 * @description Adding properties to inherit outside the function
 * 
 */
Master.prototype.print = function(){
    console.log('\n\nValues\n\tnumber:%d\n\tstring:%s',this.num,this.str);
}
Master.prototype.duplicate = function(){
    return new this.constructor(this.num,this.str);
}

a = new Master(1,'Hi');
a.print()

console.log("a is a Master:",a.duplicate() instanceof Master);

/**
 * 
 * @param {Number} num any number 
 * @param {String} str any String
 * @param {Function} func any function
 * @description The properties are binded using Master by pointing Child1 object to set values except new parameter function. 
 */
let Child1 = function(num,str,func){
    Master.call(this,num,str);
    this.func = func;
}

/**
 * @description To use Masters methods which initiated outside (inherit) Master's prototype copy is taken into Child1 object. And to constructor changes with that prototype assignment to Master. So it has to be again named to Child1. If you did not get what that means, If constructor line wasn't there, the output of line 49 will be false. In other words  "duplicate of b is not an instanceof Child1"
 */
Child1.prototype = Object.create(Master.prototype)
Child1.prototype.constructor = Child1;

b = new Child1(3,4,a.print);
b.print()

console.log("a is a Master:",b.duplicate() instanceof Master)
console.log("b is a Child1:",(b.duplicate() instanceof Child1));

/**
 * @extends Master a subclass of Master by definition
 * @description So basically. All the effort had been done previously has been done automatically. Which are, the prototype methods outside are already inherited now.
 */
class Child2 extends Master{
    /**
     * 
     * @param {Number} num any number 
     * @param {String} str any String
     * @param {Function} func any function
     * @description In here, The super method uses instead of call previously so that both call and bind will be happen special to classes.
     */
    constructor(num,str,func){
        super(num,str);
        this.func = func
    }
}

c = new Child2(11,'Class',b.print);
c.print()

console.log("c is a Master:",c.duplicate() instanceof Master)
console.log("c is a Child2:",c.duplicate() instanceof Child2)
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Child2.html">Child2</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Child1">Child1</a></li><li><a href="global.html#Master">Master</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 30 2019 19:10:34 GMT+0530 (+0530)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
